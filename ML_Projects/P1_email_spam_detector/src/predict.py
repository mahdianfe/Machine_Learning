# src/predict.py


#🔹 برای استفاده از مدل روی ایمیل جدید:
# 🔹 متن ایمیل جدید را عددی می‌کند و نتیجه (۰ یا ۱) را برمی‌گرداند.
# predict.py: فقط یک ماژول کمکی است که تابع predict_email(text) را تعریف می‌کند.
# و این تابع یک متن می‌گیرد و نتیجه‌ی پیش‌بینی را (۰ یا ۱) برمی‌گرداند. خودش به‌تنهایی چیزی چاپ نمی‌کند.
#  اما فایل predict_email.py: یک اسکریپت قابل اجرا است که ایمیل‌های نمونه را به تابع predict_email() می‌دهد و نتیجه را چاپ می‌کند.

# توضیح بیشتر
#  پس:
#     predict.py = تابع منطقی برای استفاده در جاهای دیگر.
#     predict_email.py = اجرای عملی و نمونه با چاپ خروجی.


from joblib import load

def predict_email(model_name, text):
    # بارگذاری مدل و بردار‌ساز بر اساس نام مدل
    model = load(f'models/{model_name}_classifier.pkl')
    vectorizer = load('models/vectorizer.pkl')
    # چون هر متن رو به یک بردار ویژگی (feature vector) تبدیل می‌کنه.
    # و در ریاضیات و یادگیری ماشین، به چنین لیست‌هایی از اعداد «بردار» گفته می‌شه.

    # تبدیل متن ایمیل به ویژگی‌های عددی
    X = vectorizer.transform([text])

    #پیش بینی
    prediction = model.predict(X)[0]
    # [0]
    # این یعنی:
    #     «از بین همه پیش‌بینی‌ها، فقط اولین (و تنها) مورد را بردار.»
    # چرا؟ چون ما فقط یک ایمیل را داریم پیش‌بینی می‌کنیم.
    # ولی چون vectorizer.transform([text]) خروجی‌اش یک آرایه با یک نمونه است،
    # مدل هم خروجی‌اش یک آرایه با یک مقدار خواهد بود.

    # در بیشتر مدلهای دو کلاسه model.predict(X) یک آرایه به نام array([1])  یا array([0])برمیگردونه
    #اگر array([0]) باشد، اولین عنصر صفر است و اگر array([1]) باشد، اولین عنصر یک است.
    # یعنی اگر ایمیل اسپم است، خروجی به شکل array([1]) خواهد بود و..


    # بازگشت نتیجه پیش‌بینی
    return "This email **IS SPAM** ❌ " if prediction == 1 else "This email is **NOT SPAM** ✅"
